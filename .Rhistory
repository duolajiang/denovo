## compute the test statistic for each subgroup
temp.t.vec=rep(NA, num.of.subgroups)
null.values=matrix(NA, nrow=num.of.subgroups, ncol=2)
for(i in 1:num.of.subgroups){
subgroup=test.matched.data[subgroup.num==unique.subg[i],]
treated.y=subgroup[,1]
control.y=subgroup[,2]
temp.t.vec[i]=wilcox.test(treated.y-temp.tau, control.y, paired=T, alternative="two.sided")$statistic
}
temp.test= C %*% temp.t.vec
if(dim(C)[1]==1){
temp.deviate.upper=(temp.test-theta0.upper)/sqrt(sigma0)
temp.deviate.lower=(temp.test-theta0.lower)/sqrt(sigma0)
}else{
temp.deviate.upper=(temp.test-theta0.upper)/sqrt(diag(sigma0))
temp.deviate.lower=(temp.test-theta0.lower)/sqrt(diag(sigma0))
}
# if two deviate bounds have the same sign, choose the minimum; otherwise, give 0.
same.sign=(temp.deviate.upper*temp.deviate.lower >= 0) # check whether two deviate bounds have the same sign.
temp.deviate=rep(0, length(temp.deviate.upper))
temp.deviate[same.sign==1]=pmin(abs(temp.deviate.upper), abs(temp.deviate.lower))[same.sign==1]
dev.mat[j,]=temp.deviate
max.deviate=max(abs(temp.deviate))
max.dev.vec[j]=max.deviate
}
critical.val=qmvnorm(1-alpha/2, mean=rep(0, length(corr0[,1])), corr=corr0)$quantile
sensi.mat[k,]=c(dev.mat[which.min(max.dev.vec),], min(max.dev.vec), critical.val)
}
sensi.mat=as.data.frame(sensi.mat)
colnames(sensi.mat)[1:(dim(C)[1])] <- rownames(C)
colnames(sensi.mat)[(dim(sensi.mat)[2]-1)]="Max"
colnames(sensi.mat)[dim(sensi.mat)[2]]="kappa"
sensi.mat$Gamma=sensi.param.vec
return(sensi.mat)
}
#' Denovo discovery of effect modification under no unmeasured confounder assumption.
#'
#' @param Data a total sample of matched pairs
#' @param split.ratio set a splitting ratio. 0.25 means using 25\% of data as a training sample.
#' @param total.significance a total significance level.
#' @param gamma a significance level that is used for estimating the confidence interval.
#' @return A result matrix with deviates is reported. The `Max` column represents the maximum value of deviates.
#' The `kappa` column represents the critical value. If `Max` is greater than 'kappa', we reject the null hypothesis.
#' @export
denovo=function(Data, split.ratio=0.25, total.significance=0.05, gamma=0.01){
# creating a training sample and obtain a tree structure
learning.from.training=denovo.training(Data=Data, split.ratio=split.ratio)
# analysis under no unmeasured confounder assumption
analysis=denovo.test(Data=Data, test.index=learning.from.training$test.index, tree=learning.from.training$tree, total.significance=total.significance, gamma=gamma)
return(analysis)
}
#' Denovo discovery of effect modification with a sensitivity analysis.
#'
#' @param Data a total sample of matched pairs.
#' @param Gamma.vec a vector of sensitivity parameter \eqn{\Gamma}.
#' @param split.ratio set a splitting ratio. 0.25 means using 25% of data as a training sample.
#' @param total.significance a total significance level.
#' @param gamma a significance level that is used for estimating the confidence interval.
#' @return A result matrix with deviates is reported. The `Max` column represents the maximum value of deviates.
#' The `kappa` column represents the critical value. If `Max` is greater than 'kappa', we reject the null hypothesis.
#' @export
denovo.sensi=function(Data, Gamma.vec, split.ratio=0.25, total.significance=0.05, gamma=0.0001){
# creating a training sample and obtain a tree structure
learning.from.training=denovo.training(Data=Data, split.ratio=split.ratio)
# Sensitivity analysis
sensi.analysis=denovo.test.sensi(Data=Data, Gamma.vec=Gamma.vec, test.index=learning.from.training$test.index, tree=learning.from.training$tree, total.significance=total.significance, gamma=gamma)
return(sensi.analysis)
}
#' Combine a tree structure with a test sample
#'
#' @param tree a tree object
#' @param x a test sample with the same data structure that is used for creating `tree`.
#' @return a list with the elements
#' \item{C}{the matrix representation of a tree.}
#' \item{new.x}{a new test sample by adding a vector of subgroup memberships.}
#' @description The fuction combines a tree object (obtained from a training sample) with a test sample.
tree.stru=function(tree, x){
library(rpart.utils)
# rpart.rules.table(tree)
# rpart.subrules.table(tree)
tree.frame=tree$frame
nodes=as.numeric(rownames(tree.frame))
terminal.node.ind=(tree.frame$var=="<leaf>")
terminal.node.num=sum(terminal.node.ind)
terminal.nodes=nodes[terminal.node.ind]
if(length(nodes)==1){
matrix.C=matrix(1, nrow=1, ncol=1)
rownames(matrix.C)=1
colnames(matrix.C)=1
x$subgroup.num=rep(1, length(x[,1]))
return(list(C=matrix.C, new.x=x))
}
parent.node.list=vector("list", terminal.node.num)
for(i in 1:terminal.node.num){
temp.t.node.num=(nodes[terminal.node.ind==1])[i]
temp.parent.node.num=c()
temp.parent.node.num[1]=temp.t.node.num
j=1
temp.p.node.end=0
while(temp.p.node.end != 1){
j=j+1
if(temp.t.node.num %% 2 ==0){
temp.p.node.end=temp.t.node.num/2
temp.parent.node.num[j]=temp.p.node.end
}else{
temp.p.node.end=(temp.t.node.num-1)/2
temp.parent.node.num[j]=temp.p.node.end
}
temp.t.node.num=temp.p.node.end
}
parent.node.list[[i]]=temp.parent.node.num
}
## create C matrix
matrix.C=matrix(0, nrow=length(nodes), ncol=length(terminal.nodes))
rownames(matrix.C)=nodes
colnames(matrix.C)=terminal.nodes
for(i in 1:terminal.node.num){
matrix.C[rownames(matrix.C) %in% parent.node.list[[i]], i]=1
}
matrix.C=matrix.C[-1,] # delete the first row
## assign the terminal node name
decision.rule=rpart.rules.table(tree)
var.rule=rpart.subrules.table(tree)
x$subgroup.num=rep(NA, length(x[,1]))
for(i in 1:terminal.node.num){
temp.t.node=terminal.nodes[i]
temp.d.rule=decision.rule[decision.rule$Rule==temp.t.node, "Subrule"]
temp.v.rule=var.rule[var.rule$Subrule %in% temp.d.rule, ]
temp.ind.matrix=matrix(NA, nrow=length(temp.d.rule), ncol=length(x[,1]))
for(j in 1:length(temp.d.rule)){
temp.var.name=temp.v.rule$Variable[j]
x.column.num=which(colnames(x)==temp.var.name)
if(is.na(temp.v.rule$Less[j])==1){
temp.ind.matrix[j,]=(x[,x.column.num] >= as.numeric(as.character(temp.v.rule$Greater[j])))
}else{
temp.ind.matrix[j,]=(x[,x.column.num] < as.numeric(as.character(temp.v.rule$Less[j])))
}
}
temp.ind=apply(temp.ind.matrix, 2, prod)
x[temp.ind==1, "subgroup.num"]=rep(temp.t.node, sum(temp.ind))
}
return(list(C=matrix.C, new.x=x))
}
#' The Wilcoxon's signed rank sum test in a sensitivity analysis.
#'
#' @param N the number of matched pairs
#' @param gamma the value of sensitivity parameter \eqn{\Gamma}
#' @return
#' \item{expect.upper}{Expectation of the upper bound.}
#' \item{expect.lower}{Expectation of the lower bound.}
#' \item{var}{Variance of both upper and lower bounds.}
wilcoxSenMoments=function(N,gamma){
#Computes null expectation and variance of Wilcoxon's statistic
#in a sensitivity analysis with parameter Gamma
#Uses formula (4.11) in Rosenbaum (2002) Observational Studies
pplus.u=gamma/(1+gamma)
pplus.l=1/(1+gamma)
expect.u=pplus.u*N*(N+1)/2
expect.l=pplus.l*N*(N+1)/2
vari=pplus.u*(1-pplus.u)*N*(N+1)*(2*N+1)/6
list(expect.upper=expect.u,expect.lower=expect.l,var=vari)
}
#' Estimation of the confidence interval for the population mean by inverting the Wilcoxon signed rank sum test.
#'
#' @param data input a test sample.
#' @param gamma set a significance level for the confidence interval estimation.
#' @param grid.size the number of values within the confidence interval.
#' @return The \eqn{100(1-\gamma)}% confidence interval for the population mean is estimated.
get.tau.vector.wilcox=function(data, gamma=0.001, grid.size=21){
wilcox.res=wilcox.test(matched.data$y_t, matched.data$y_c, paired=T, alternative="two.sided", conf.int=T, conf.level=1-gamma)
conf.int.vec=seq(wilcox.res$conf.int[1], wilcox.res$conf.int[2], by=(wilcox.res$conf.int[2]-wilcox.res$conf.int[1])/(grid.size-1))
return(conf.int.vec)
}
data("sim_data")
denovo(Data = matched.data)
library(denovo)
data("sim_data")
denovo(Data = matched.data)
get.tau.vector.wilcox(data=matched.data)
get.tau.vector.wilcox=function(data, gamma=0.001, grid.size=21){
wilcox.res=wilcox.test(data[,1], data[,2], paired=T, alternative="two.sided", conf.int=T, conf.level=1-gamma)
conf.int.vec=seq(wilcox.res$conf.int[1], wilcox.res$conf.int[2], by=(wilcox.res$conf.int[2]-wilcox.res$conf.int[1])/(grid.size-1))
return(conf.int.vec)
}
get.tau.vector.wilcox(data=matched.data)
data("sim_data")
denovo(Data = matched.data)
denovo(Data=matched.data)
denovo.training(Data=matched.data)
Data=matched.data
split.ratio=0.25
n=dim(Data)[1] # number of pairs
m=dim(Data)[2]
training.data.index=sample(1:n, round(n*split.ratio), replace=F)
test.data.index=(1:n)[-training.data.index]
tra.matched.data=Data[training.data.index, ]
tra.matched.data=as.data.frame(tra.matched.data)
################################################################################################
######### Discovering tree structures in the first subsample (training sample)
################################################################################################
### training sample -> Create tree using CART
res=rpart((tra.matched.data[,1]-tra.matched.data[,2]) ~. , data=tra.matched.data, method="anova", control=rpart.control(cp=0))
opt.cp=res$cptable[,1][which.min(res$cptable[,4])]
pruned=prune(res, opt.cp) ## obtained tree from a training sample
pruned
res
res$cptable
tra.matched.data[1:10,]
dim(tra.matched.data)
(tra.matched.data[,1]-tra.matched.data[,2])
tra.matched.data[1:10,1:2]
res=rpart((tra.matched.data[,1]-tra.matched.data[,2]) ~. , method="anova", control=rpart.control(cp=0))
opt.cp=res$cptable[,1][which.min(res$cptable[,4])]
pruned=prune(res, opt.cp) ## obtained tree from a training sample
n=dim(Data)[1] # number of pairs
m=dim(Data)[2]
training.data.index=sample(1:n, round(n*split.ratio), replace=F)
test.data.index=(1:n)[-training.data.index]
tra.matched.data=Data[training.data.index, ]
tra.matched.data=as.data.frame(tra.matched.data)
################################################################################################
######### Discovering tree structures in the first subsample (training sample)
################################################################################################
### training sample -> Create tree using CART
res=rpart((tra.matched.data[,1]-tra.matched.data[,2]) ~. , data=tra.matched.data, method="anova", control=rpart.control(cp=0))
opt.cp=res$cptable[,1][which.min(res$cptable[,4])]
pruned=prune(res, opt.cp) ## obtained tree from a training sample
pruned
res
res$cptable
res=rpart((tra.matched.data[,1]-tra.matched.data[,2]) ~ tra.matched.data[,3:m], data=tra.matched.data, method="anova", control=rpart.control(cp=0))
opt.cp=res$cptable[,1][which.min(res$cptable[,4])]
pruned=prune(res, opt.cp) ## obtained tree from a training sample
library(denovo)
#' Find an effect modification structure from data.
#'
#' @param Data input matched pairs. The first column must contain outcomes for treated subjects and the second column must contain outcomes for control subjects. The remaining columns contain shared covariates.
#' @param split.ratio set a splitting ratio. 0.25 means using 25\% of data as a training sample.
#' @return A list with the elements:
#' \item{training.index}{an index set for indicating a training sample that is randomly chosen.}
#' \item{test.index}{an index set for indicating a test sample.}
#' \item{tree}{discovered effect modification tree structure.}
#' @export
denovo.training=function(Data, split.ratio=0.25){
n=dim(Data)[1] # number of pairs
m=dim(Data)[2]
colnames(Data)[1:2]=c("Y_t", "Y_c")
training.data.index=sample(1:n, round(n*split.ratio), replace=F)
test.data.index=(1:n)[-training.data.index]
tra.matched.data=Data[training.data.index, ]
tra.matched.data=as.data.frame(tra.matched.data)
################################################################################################
######### Discovering tree structures in the first subsample (training sample)
################################################################################################
### training sample -> Create tree using CART
res=rpart((Y_t-Y_c)~., data=tra.matched.data, method="anova", control=rpart.control(cp=0))
opt.cp=res$cptable[,1][which.min(res$cptable[,4])]
pruned=prune(res, opt.cp) ## obtained tree from a training sample
return(list(training.index=training.data.index, test.index=test.data.index, tree=pruned))
}
#' Conduct a hypothesis test under no unmeasured confounder assumption.
#'
#' @param Data a total sample of matched pairs.
#' @param test.index an index set that indicates a test sample in the total sample.
#' @param tree an effect modification tree that needs to be tested.
#' @param total.significance a total significance level.
#' @param gamma a significance level that is used for estimating the confidence interval.
#' @return A result matrix with deviates is reported. The `Max` column represents the maximum value of deviates.
#' The `kappa` column represents the critical value.
#' @export
denovo.test=function(Data, test.index, tree, total.significance=0.05, gamma=0.01){
test.matched.data=Data[test.index,]
test.matched.data=as.data.frame(test.matched.data)
test.tree.stru=tree.stru(tree=tree, x=test.matched.data)
subgroup.num=test.tree.stru$new.x$subgroup.num
unique.subg=as.numeric(colnames(test.tree.stru$C))
num.of.subgroups=length(unique.subg)
########################################################################################################
##### Use the second sample (test sample)
##### test of effect modification when Gamma=1 (under no unmeasured confounder assumption)
########################################################################################################
C=test.tree.stru$C
# set significance levels
alpha=total.significance-gamma
# Since the population treatment effect size (tau) is not known, we estimate the 100(1-gamma)% CI of tau.
tau.vec=get.tau.vector.wilcox(test.matched.data, gamma=gamma)
null.values=matrix(NA, nrow=num.of.subgroups, ncol=3)
for(i in 1:num.of.subgroups){
## null values
null.values[i,]=as.vector(unlist(wilcoxSenMoments(sum(subgroup.num==unique.subg[i]), gamma=1)))
}
mu=null.values[,1]; V=null.values[,3];
if(dim(C)[1]==1){
theta0= mu
sigma0= V
corr0= C
}else{
theta0= C %*% mu
sigma0= C %*% diag(V) %*% t(C)
corr0=sigma0/sqrt(outer(diag(sigma0),diag(sigma0),"*"))
}
max.dev.vec=rep(NA, length(tau.vec))
dev.mat=matrix(NA, nrow=length(tau.vec), ncol=dim(C)[1])
for(j in 1:length(tau.vec)){
temp.tau=tau.vec[j]
## compute the test statistic T for each subgroup
temp.t.vec=rep(NA, num.of.subgroups)
for(i in 1:num.of.subgroups){
subgroup=test.matched.data[subgroup.num==unique.subg[i],]
treated.y=subgroup[,1]
control.y=subgroup[,2]
temp.t.vec[i]=wilcox.test(treated.y-temp.tau, control.y, paired=T, alternative="two.sided")$statistic
}
## compute the comparisons using S=CT
temp.test= C %*% temp.t.vec
if(dim(C)[1]==1){
temp.deviate=(temp.test-theta0)/sqrt(sigma0)
}else{
temp.deviate=(temp.test-theta0)/sqrt(diag(sigma0))
}
dev.mat[j,]=temp.deviate
max.deviate=max(abs(temp.deviate))
max.dev.vec[j]=max.deviate
}
## Critical value at alpha.
if(dim(C)[1]==1){
critical.val=qnorm(1-alpha/2)
}else{
critical.val=qmvnorm(1-alpha/2, mean=rep(0, length(corr0[,1])), corr=corr0)$quantile
}
dev.res.mat=cbind(dev.mat, max.dev.vec, rep(critical.val, length(max.dev.vec))) #
colnames(dev.res.mat)=c(rownames(C), "Max", "kappa")
dev.res.mat=as.data.frame(dev.res.mat)
dev.res.mat$tau=tau.vec
return(dev.res.mat)
}
#' Conduct a sensitivity analysis
#'
#' @param Data a total sample of matched pairs.
#' @param test.index an index set that indicates a test sample in the total sample.
#' @param tree an effect modification tree that needs to be tested.
#' @param Gamma.vec a vector of sensitivity parameter \eqn{\Gamma}.
#' @param total.significance a total significance level.
#' @param gamma a significance level that is used for estimating the confidence interval.
#' @return A result matrix with deviates is reported. The `Max` column represents the maximum value of deviates.
#' The `kappa` column represents the critical value. If `Max` is greater than 'kappa', we reject the null hypothesis.
#' @export
denovo.test.sensi=function(Data, test.index, tree, Gamma.vec, total.significance=0.05, gamma=0.0001){
test.matched.data=Data[test.index,]
test.matched.data=as.data.frame(test.matched.data)
test.tree.stru=tree.stru(tree=tree, x=test.matched.data)
subgroup.num=test.tree.stru$new.x$subgroup.num
unique.subg=as.numeric(colnames(test.tree.stru$C))
num.of.subgroups=length(unique.subg)
C=test.tree.stru$C
########################################################################
########## Sensitivity analysis with various values of Gamma. ##########
########################################################################
sensi.param.vec=Gamma.vec # need to specify this vector.
alpha=total.significance-gamma
# Instead of estimating the 100(1-gamma)% CI of tau, choose a wide enough interval for tau
tau.vec=get.tau.vector.wilcox(test.matched.data, gamma=gamma)
sensi.mat=matrix(NA, nrow=length(sensi.param.vec), ncol=dim(C)[1]+2)
for(k in 1:length(sensi.param.vec)){
Gamma=sensi.param.vec[k]
null.values=matrix(NA, nrow=num.of.subgroups, ncol=3)
for(i in 1:num.of.subgroups){
## null values
null.values[i,]=as.vector(unlist(wilcoxSenMoments(sum(subgroup.num==unique.subg[i]), gamma=Gamma)))
}
mu.upper=null.values[,1] # lower bound of Exp.
mu.lower=null.values[,2] # upper bound of Exp.
V=null.values[,3]
if(dim(C)[1]==1){
theta0.upper= mu.upper
theta0.lower= mu.lower
sigma0= V
corr0= C
}else{
theta0.upper= C %*% mu.upper
theta0.lower= C %*% mu.lower
sigma0= C %*% diag(V) %*% t(C)
corr0=sigma0/sqrt(outer(diag(sigma0),diag(sigma0),"*"))
}
max.dev.vec=rep(NA, length(tau.vec))
dev.mat=matrix(NA, nrow=length(tau.vec), ncol=dim(C)[1])
for(j in 1:length(tau.vec)){
temp.tau=tau.vec[j]
## compute the test statistic for each subgroup
temp.t.vec=rep(NA, num.of.subgroups)
null.values=matrix(NA, nrow=num.of.subgroups, ncol=2)
for(i in 1:num.of.subgroups){
subgroup=test.matched.data[subgroup.num==unique.subg[i],]
treated.y=subgroup[,1]
control.y=subgroup[,2]
temp.t.vec[i]=wilcox.test(treated.y-temp.tau, control.y, paired=T, alternative="two.sided")$statistic
}
temp.test= C %*% temp.t.vec
if(dim(C)[1]==1){
temp.deviate.upper=(temp.test-theta0.upper)/sqrt(sigma0)
temp.deviate.lower=(temp.test-theta0.lower)/sqrt(sigma0)
}else{
temp.deviate.upper=(temp.test-theta0.upper)/sqrt(diag(sigma0))
temp.deviate.lower=(temp.test-theta0.lower)/sqrt(diag(sigma0))
}
# if two deviate bounds have the same sign, choose the minimum; otherwise, give 0.
same.sign=(temp.deviate.upper*temp.deviate.lower >= 0) # check whether two deviate bounds have the same sign.
temp.deviate=rep(0, length(temp.deviate.upper))
temp.deviate[same.sign==1]=pmin(abs(temp.deviate.upper), abs(temp.deviate.lower))[same.sign==1]
dev.mat[j,]=temp.deviate
max.deviate=max(abs(temp.deviate))
max.dev.vec[j]=max.deviate
}
critical.val=qmvnorm(1-alpha/2, mean=rep(0, length(corr0[,1])), corr=corr0)$quantile
sensi.mat[k,]=c(dev.mat[which.min(max.dev.vec),], min(max.dev.vec), critical.val)
}
sensi.mat=as.data.frame(sensi.mat)
colnames(sensi.mat)[1:(dim(C)[1])] <- rownames(C)
colnames(sensi.mat)[(dim(sensi.mat)[2]-1)]="Max"
colnames(sensi.mat)[dim(sensi.mat)[2]]="kappa"
sensi.mat$Gamma=sensi.param.vec
return(sensi.mat)
}
#' Denovo discovery of effect modification under no unmeasured confounder assumption.
#'
#' @param Data a total sample of matched pairs
#' @param split.ratio set a splitting ratio. 0.25 means using 25\% of data as a training sample.
#' @param total.significance a total significance level.
#' @param gamma a significance level that is used for estimating the confidence interval.
#' @return A result matrix with deviates is reported. The `Max` column represents the maximum value of deviates.
#' The `kappa` column represents the critical value. If `Max` is greater than 'kappa', we reject the null hypothesis.
#' @export
denovo=function(Data, split.ratio=0.25, total.significance=0.05, gamma=0.01){
# creating a training sample and obtain a tree structure
learning.from.training=denovo.training(Data=Data, split.ratio=split.ratio)
# analysis under no unmeasured confounder assumption
analysis=denovo.test(Data=Data, test.index=learning.from.training$test.index, tree=learning.from.training$tree, total.significance=total.significance, gamma=gamma)
return(analysis)
}
#' Denovo discovery of effect modification with a sensitivity analysis.
#'
#' @param Data a total sample of matched pairs.
#' @param Gamma.vec a vector of sensitivity parameter \eqn{\Gamma}.
#' @param split.ratio set a splitting ratio. 0.25 means using 25% of data as a training sample.
#' @param total.significance a total significance level.
#' @param gamma a significance level that is used for estimating the confidence interval.
#' @return A result matrix with deviates is reported. The `Max` column represents the maximum value of deviates.
#' The `kappa` column represents the critical value. If `Max` is greater than 'kappa', we reject the null hypothesis.
#' @export
denovo.sensi=function(Data, Gamma.vec, split.ratio=0.25, total.significance=0.05, gamma=0.0001){
# creating a training sample and obtain a tree structure
learning.from.training=denovo.training(Data=Data, split.ratio=split.ratio)
# Sensitivity analysis
sensi.analysis=denovo.test.sensi(Data=Data, Gamma.vec=Gamma.vec, test.index=learning.from.training$test.index, tree=learning.from.training$tree, total.significance=total.significance, gamma=gamma)
return(sensi.analysis)
}
n=dim(Data)[1] # number of pairs
m=dim(Data)[2]
colnames(Data)[1:2]=c("Y_t", "Y_c")
training.data.index=sample(1:n, round(n*split.ratio), replace=F)
test.data.index=(1:n)[-training.data.index]
tra.matched.data=Data[training.data.index, ]
tra.matched.data=as.data.frame(tra.matched.data)
################################################################################################
######### Discovering tree structures in the first subsample (training sample)
################################################################################################
### training sample -> Create tree using CART
res=rpart((Y_t-Y_c)~., data=tra.matched.data, method="anova", control=rpart.control(cp=0))
opt.cp=res$cptable[,1][which.min(res$cptable[,4])]
pruned=prune(res, opt.cp) ## obtained tree from a training sample
res
pruned
data("sim_data")
denovo(Data = matched.data)
data("sim_data")
denovo(Data = matched.data)
data("sim_data")
denovo(Data = matched.data)
denovo.sensi(Data=matched.data, Gamma.vec=c(1,1.05, 1.1, 1.15, 1.2, 1.25, 1.3))
library(denovo)
library(denovo)
library(denovo)
data("sim_data")
denovo(Data=matched.data)
library(denovo)
data("sim_data")
denovo(Data=matched.data)
library(denovo)
data("sim_data")
denovo(Data=matched.data)
library(denovo)
data("sim_data")
denovo(Data=matched.data)
library(denovo)
data("sim_data")
denovo(Data=matched.data)
library(denovo)
data("sim_data")
denovo(Data=matched.data)
data("sim_data")
denovo(Data=matched.data)
library(denovo)
devtools::document()
library(denovo)
?wilcox.test
library(denovo)
devtools::document()
devtools::document()
library(denovo)
?rpart.util
library(denovo)
library(denovo)
